# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

module ActionMailbox
  extend(::ActiveSupport::Autoload)

  def incinerate; end
  def incinerate=(obj); end
  def incinerate_after; end
  def incinerate_after=(obj); end
  def ingress; end
  def ingress=(obj); end
  def logger; end
  def logger=(obj); end
  def queues; end
  def queues=(obj); end

  def self.incinerate; end
  def self.incinerate=(obj); end
  def self.incinerate_after; end
  def self.incinerate_after=(obj); end
  def self.ingress; end
  def self.ingress=(obj); end
  def self.logger; end
  def self.logger=(obj); end
  def self.queues; end
  def self.queues=(obj); end
  def self.railtie_helpers_paths; end
  def self.railtie_namespace; end
  def self.railtie_routes_url_helpers(include_path_helpers = _); end
  def self.table_name_prefix; end
  def self.use_relative_model_naming?; end
end

class ActionMailbox::Base
  include(::ActionMailbox::Callbacks)
  include(::ActiveSupport::Callbacks)
  include(::ActionMailbox::Routing)
  include(::ActiveSupport::Rescuable)
  extend(::ActionMailbox::Callbacks::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::ActionMailbox::Routing::ClassMethods)
  extend(::ActiveSupport::Rescuable::ClassMethods)

  def initialize(inbound_email); end

  def __callbacks; end
  def __callbacks?; end
  def _process_callbacks; end
  def _run_process_callbacks(&block); end
  def bounce_with(message); end
  def bounced!(*args, &block); end
  def delivered!(*args, &block); end
  def finished_processing?; end
  def inbound_email; end
  def logger(*args, &block); end
  def mail(*args, &block); end
  def perform_processing; end
  def process; end
  def rescue_handlers; end
  def rescue_handlers=(val); end
  def rescue_handlers?; end
  def router; end
  def router=(obj); end

  private

  def track_status_of_inbound_email; end

  def self.__callbacks; end
  def self.__callbacks=(val); end
  def self.__callbacks?; end
  def self._process_callbacks; end
  def self._process_callbacks=(value); end
  def self.receive(inbound_email); end
  def self.rescue_handlers; end
  def self.rescue_handlers=(val); end
  def self.rescue_handlers?; end
  def self.router; end
  def self.router=(obj); end
end

class ActionMailbox::BaseController < ::ActionController::Base

  private

  def _layout(lookup_context, formats); end
  def authenticate_by_password; end
  def ensure_configured; end
  def ingress_name; end
  def password; end

  def self.__callbacks; end
  def self._helpers; end
  def self.middleware_stack; end
end

class ActionMailbox::Engine < ::Rails::Engine
end

class ActionMailbox::InboundEmail < ::ActiveRecord::Base
  include(::ActionMailbox::InboundEmail::Incineratable)
  include(::ActionMailbox::InboundEmail::MessageId)
  include(::ActionMailbox::InboundEmail::Routable)
  extend(::ActionMailbox::InboundEmail::MessageId::ClassMethods)

  def self.__callbacks; end
  def self._validators; end
  def self.attribute_type_decorations; end
  def self.defined_enums; end
end

module ActionMailbox::InboundEmail::Incineratable
  extend(::ActiveSupport::Concern)

  def incinerate; end
  def incinerate_later; end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run; end

  private

  def due?; end
  def processed?; end
end

module ActionMailbox::InboundEmail::MessageId
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(ClassMethods)
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end

  private

  def extract_message_id(source); end
  def generate_missing_message_id(message_checksum); end
end

module ActionMailbox::InboundEmail::Routable
  extend(::ActiveSupport::Concern)

  def route; end
  def route_later; end
end

class ActionMailbox::IncinerationJob < ::ActiveJob::Base
  def perform(inbound_email); end

  def self.queue_name; end
  def self.rescue_handlers; end
  def self.schedule(inbound_email); end
end

class ActionMailbox::Router
  def initialize; end

  def add_route(address, to:); end
  def add_routes(routes); end
  def route(inbound_email); end

  private

  def match_to_mailbox(inbound_email); end
  def routes; end
end

class ActionMailbox::Router::Route
  def initialize(address, to:); end

  def address; end
  def mailbox_class; end
  def mailbox_name; end
  def match?(inbound_email); end

  private

  def ensure_valid_address; end
end

class ActionMailbox::Router::RoutingError < ::StandardError
end

class ActionMailbox::RoutingJob < ::ActiveJob::Base
  def perform(inbound_email); end

  def self.queue_name; end
end

class ActionMailbox::TestCase < ::ActiveSupport::TestCase
  include(::ActionMailbox::TestHelper)
end

module ActionMailbox::Callbacks
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(ClassMethods)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end
  def around_processing(*methods, &block); end
  def before_processing(*methods, &block); end
end

ActionMailbox::Callbacks::TERMINATOR = T.let(T.unsafe(nil), Proc)

module ActionMailbox::Routing
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(ClassMethods)
end

module ActionMailbox::Routing::ClassMethods
  def route(inbound_email); end
  def routing(routes); end
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: _); end
  def create_inbound_email_from_mail(status: _, **mail_options); end
  def create_inbound_email_from_source(source, status: _); end
  def receive_inbound_email_from_fixture(*args); end
  def receive_inbound_email_from_mail(**kwargs); end
  def receive_inbound_email_from_source(*args); end
end

module Mail
  def self.all(*args, &block); end
  def self.connection(&block); end
  def self.defaults(&block); end
  def self.delete_all(*args, &block); end
  def self.deliver(*args, &block); end
  def self.delivery_method; end
  def self.eager_autoload!; end
  def self.find(*args, &block); end
  def self.find_and_delete(*args, &block); end
  def self.first(*args, &block); end
  def self.from_source(source); end
  def self.inform_interceptors(mail); end
  def self.inform_observers(mail); end
  def self.last(*args, &block); end
  def self.new(*args, &block); end
  def self.random_tag; end
  def self.read(filename); end
  def self.read_from_string(mail_as_string); end
  def self.register_autoload(name, path); end
  def self.register_interceptor(interceptor); end
  def self.register_observer(observer); end
  def self.retriever_method; end
  def self.something_random; end
  def self.uniq; end
  def self.unregister_interceptor(interceptor); end
  def self.unregister_observer(observer); end
end

class Mail::Address
  include(::Mail::Utilities)
  include(::Mail::Constants)

  def initialize(value = _); end

  def ==(other_address); end
  def address(output_type = _); end
  def address=(value); end
  def comments; end
  def decoded; end
  def display_name(output_type = _); end
  def display_name=(str); end
  def domain(output_type = _); end
  def encoded; end
  def format(output_type = _); end
  def group; end
  def inspect; end
  def local(output_type = _); end
  def name; end
  def raw; end
  def to_s; end

  private

  def format_comments; end
  def get_comments; end
  def get_display_name; end
  def get_domain; end
  def get_local; end
  def get_name; end
  def parse(value = _); end
  def strip_all_comments(string); end
  def strip_domain_comments(value); end

  def self.wrap(address); end
end

class Mail::Message
  include(::Mail::Utilities)
  include(::Mail::Constants)

  def initialize(*args, &block); end

  def <=>(other); end
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def action; end
  def add_charset; end
  def add_content_transfer_encoding; end
  def add_content_type; end
  def add_date(date_val = _); end
  def add_file(values); end
  def add_message_id(msg_id_val = _); end
  def add_mime_version(ver_val = _); end
  def add_part(part); end
  def add_transfer_encoding; end
  def all_parts; end
  def attachment; end
  def attachment?; end
  def attachments; end
  def bcc(val = _); end
  def bcc=(val); end
  def bcc_addresses; end
  def bcc_addrs; end
  def body(value = _); end
  def body=(value); end
  def body_encoding(value = _); end
  def body_encoding=(value); end
  def bounced?; end
  def boundary; end
  def cc(val = _); end
  def cc=(val); end
  def cc_addresses; end
  def cc_addrs; end
  def charset; end
  def charset=(value); end
  def comments(val = _); end
  def comments=(val); end
  def content_description(val = _); end
  def content_description=(val); end
  def content_disposition(val = _); end
  def content_disposition=(val); end
  def content_id(val = _); end
  def content_id=(val); end
  def content_location(val = _); end
  def content_location=(val); end
  def content_transfer_encoding(val = _); end
  def content_transfer_encoding=(val); end
  def content_type(val = _); end
  def content_type=(val); end
  def content_type_parameters; end
  def convert_to_multipart; end
  def date(val = _); end
  def date=(val); end
  def decode_body; end
  def decoded; end
  def default(sym, val = _); end
  def deliver; end
  def deliver!; end
  def delivery_handler; end
  def delivery_handler=(_); end
  def delivery_method(method = _, settings = _); end
  def delivery_status_part; end
  def delivery_status_report?; end
  def destinations; end
  def diagnostic_code; end
  def encode!; end
  def encoded; end
  def envelope_date; end
  def envelope_from; end
  def error_status; end
  def errors; end
  def filename; end
  def final_recipient; end
  def find_first_mime_type(mt); end
  def from(val = _); end
  def from=(val); end
  def from_address; end
  def from_addrs; end
  def has_attachments?; end
  def has_charset?; end
  def has_content_transfer_encoding?; end
  def has_content_type?; end
  def has_date?; end
  def has_message_id?; end
  def has_mime_version?; end
  def has_transfer_encoding?; end
  def header(value = _); end
  def header=(value); end
  def header_fields; end
  def headers(hash = _); end
  def html_part(&block); end
  def html_part=(msg); end
  def in_reply_to(val = _); end
  def in_reply_to=(val); end
  def inform_interceptors; end
  def inform_observers; end
  def inspect; end
  def is_marked_for_delete?; end
  def keywords(val = _); end
  def keywords=(val); end
  def main_type; end
  def mark_for_delete=(value = _); end
  def message_content_type; end
  def message_id(val = _); end
  def message_id=(val); end
  def method_missing(name, *args, &block); end
  def mime_parameters; end
  def mime_type; end
  def mime_version(val = _); end
  def mime_version=(val); end
  def multipart?; end
  def multipart_report?; end
  def part(params = _); end
  def parts; end
  def perform_deliveries; end
  def perform_deliveries=(_); end
  def raise_delivery_errors; end
  def raise_delivery_errors=(_); end
  def raw_envelope; end
  def raw_source; end
  def read; end
  def ready_to_send!; end
  def received(val = _); end
  def received=(val); end
  def recipients; end
  def recipients_addresses; end
  def references(val = _); end
  def references=(val); end
  def register_for_delivery_notification(observer); end
  def remote_mta; end
  def reply(*args, &block); end
  def reply_to(val = _); end
  def reply_to=(val); end
  def resent_bcc(val = _); end
  def resent_bcc=(val); end
  def resent_cc(val = _); end
  def resent_cc=(val); end
  def resent_date(val = _); end
  def resent_date=(val); end
  def resent_from(val = _); end
  def resent_from=(val); end
  def resent_message_id(val = _); end
  def resent_message_id=(val); end
  def resent_sender(val = _); end
  def resent_sender=(val); end
  def resent_to(val = _); end
  def resent_to=(val); end
  def retryable?; end
  def return_path(val = _); end
  def return_path=(val); end
  def sender(val = _); end
  def sender=(val); end
  def set_envelope(val); end
  def skip_deletion; end
  def smtp_envelope_from(val = _); end
  def smtp_envelope_from=(val); end
  def smtp_envelope_to(val = _); end
  def smtp_envelope_to=(val); end
  def sub_type; end
  def subject(val = _); end
  def subject=(val); end
  def text?; end
  def text_part(&block); end
  def text_part=(msg); end
  def to(val = _); end
  def to=(val); end
  def to_addresses; end
  def to_addrs; end
  def to_s; end
  def to_yaml(opts = _); end
  def transfer_encoding; end
  def transport_encoding(val = _); end
  def transport_encoding=(val); end
  def without_attachments!; end
  def x_original_to_addresses; end

  private

  def add_boundary; end
  def add_encoding_to_body; end
  def add_multipart_alternate_header; end
  def add_multipart_mixed_header; end
  def add_required_fields; end
  def add_required_message_fields; end
  def allowed_encodings; end
  def body_lazy(value); end
  def decode_body_as_text; end
  def do_delivery; end
  def find_attachment; end
  def identify_and_set_transfer_encoding; end
  def init_with_hash(hash); end
  def init_with_string(string); end
  def initialize_copy(original); end
  def parse_message; end
  def process_body_raw; end
  def raw_source=(value); end
  def separate_parts; end
  def set_envelope_header; end

  def self.default_charset; end
  def self.default_charset=(charset); end
  def self.from_hash(hash); end
  def self.from_yaml(str); end
end

Mail::Message::HEADER_SEPARATOR = T.let(T.unsafe(nil), Regexp)

Mail::RANDOM_TAG = T.let(T.unsafe(nil), String)

Mail::RubyVer = Mail::Ruby19

module Rails
  extend(::ActiveSupport::Autoload)

  def self.app_class; end
  def self.app_class=(_); end
  def self.application; end
  def self.application=(_); end
  def self.autoloaders; end
  def self.backtrace_cleaner; end
  def self.cache; end
  def self.cache=(_); end
  def self.configuration; end
  def self.env; end
  def self.env=(environment); end
  def self.gem_version; end
  def self.groups(*groups); end
  def self.initialize!(*args, &block); end
  def self.initialized?(*args, &block); end
  def self.logger; end
  def self.logger=(_); end
  def self.public_path; end
  def self.root; end
  def self.version; end
end
