# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

class InterruptHandler
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def initialize; end

  def isolate_signals; end
  def isolate_signals=(_); end
  def reenable_on_interrupt; end
  def reenable_on_interrupt=(_); end
  def signal_received; end
  def signal_received=(_); end

  def self.disable!; end
  def self.disable_until_finished_or_interrupted; end
  def self.enable!; end
  def self.instance; end
  def self.isolate_from_interrupts; end
end

module Overcommit
end

Overcommit::BUG_REPORT_URL = T.let(T.unsafe(nil), String)

Overcommit::CONFIG_FILE_NAME = T.let(T.unsafe(nil), String)

class Overcommit::CommandSplitter
  def self.execute(initial_args, options); end
end

class Overcommit::CommandSplitter::Result < ::Struct
  def status; end
  def statuses; end
  def statuses=(_); end
  def stderr; end
  def stderrs; end
  def stderrs=(_); end
  def stdout; end
  def stdouts; end
  def stdouts=(_); end
  def success?; end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class Overcommit::Configuration
  def initialize(hash, options = _); end

  def ==(other); end
  def [](key); end
  def all_builtin_hook_configs; end
  def all_hook_configs; end
  def all_plugin_hook_configs; end
  def apply_environment!(hook_context, env); end
  def concurrency; end
  def enabled_ad_hoc_hooks(hook_context); end
  def enabled_builtin_hooks(hook_context); end
  def for_hook(hook, hook_type = _); end
  def merge(config); end
  def plugin_directory; end
  def plugin_hook?(hook_context_or_type, hook_name); end
  def previous_signature?; end
  def signature_changed?; end
  def update_signature!; end
  def verify_signatures?; end

  protected

  def hash; end

  private

  def ad_hoc_hook?(hook_context, hook_name); end
  def built_in_hook?(hook_context, hook_name); end
  def hook_enabled?(hook_context_or_type, hook_name); end
  def hook_exists?(hook_context, hook_name); end
  def signature; end
  def signature_config_key; end
  def smart_merge(parent, child); end
  def stored_signature; end
  def verify_signature_config_key; end
end

class Overcommit::ConfigurationLoader
  def initialize(logger, options = _); end

  def load_file(file); end
  def load_repo_config; end

  private

  def verify_signatures(config); end

  def self.default_configuration; end
  def self.load_from_file(file, options = _); end
end

Overcommit::ConfigurationLoader::DEFAULT_CONFIG_PATH = T.let(T.unsafe(nil), String)

class Overcommit::ConfigurationValidator
  def validate(config, hash, options); end

  private

  def check_for_missing_enabled_option(hash); end
  def check_for_too_many_processors(config, hash); end
  def check_for_verify_plugin_signatures_option(hash); end
  def check_hook_env(hash); end
  def check_hook_name_format(hash); end
  def convert_nils_to_empty_hashes(hash); end
  def ensure_hook_type_sections_exist(hash); end
end

module Overcommit::Exceptions
end

class Overcommit::Exceptions::ConfigurationError < ::StandardError
end

class Overcommit::Exceptions::ConfigurationSignatureChanged < ::StandardError
end

class Overcommit::Exceptions::GitConfigError < ::StandardError
end

class Overcommit::Exceptions::GitRevListError < ::StandardError
end

class Overcommit::Exceptions::GitSubmoduleError < ::StandardError
end

class Overcommit::Exceptions::HookCancelled < ::StandardError
end

class Overcommit::Exceptions::HookCleanupFailed < ::StandardError
end

class Overcommit::Exceptions::HookContextLoadError < ::StandardError
end

class Overcommit::Exceptions::HookLoadError < ::StandardError
end

class Overcommit::Exceptions::HookSetupFailed < ::StandardError
end

class Overcommit::Exceptions::InvalidCommandArgs < ::StandardError
end

class Overcommit::Exceptions::InvalidGitRepo < ::StandardError
end

class Overcommit::Exceptions::InvalidHookDefinition < ::StandardError
end

class Overcommit::Exceptions::InvalidHookSignature < ::StandardError
end

class Overcommit::Exceptions::MessageProcessingError < ::StandardError
end

class Overcommit::Exceptions::PreExistingHooks < ::StandardError
end

Overcommit::GIT_VERSION = T.let(T.unsafe(nil), Overcommit::Utils::Version)

module Overcommit::GitConfig

  private

  def comment_character; end
  def hooks_path; end

  def self.comment_character; end
  def self.hooks_path; end
end

module Overcommit::GitRepo

  private

  def all_files; end
  def branches_containing_commit(commit_ref); end
  def current_branch; end
  def extract_modified_lines(file_path, options); end
  def initial_commit?; end
  def list_files(paths = _, options = _); end
  def modified_files(options); end
  def restore_cherry_pick_state; end
  def restore_merge_state; end
  def staged_submodule_removals; end
  def store_cherry_pick_state; end
  def store_merge_state; end
  def submodule_statuses(options = _); end
  def submodules(options = _); end
  def tracked?(path); end

  def self.all_files; end
  def self.branches_containing_commit(commit_ref); end
  def self.current_branch; end
  def self.extract_modified_lines(file_path, options); end
  def self.initial_commit?; end
  def self.list_files(paths = _, options = _); end
  def self.modified_files(options); end
  def self.restore_cherry_pick_state; end
  def self.restore_merge_state; end
  def self.staged_submodule_removals; end
  def self.store_cherry_pick_state; end
  def self.store_merge_state; end
  def self.submodule_statuses(options = _); end
  def self.submodules(options = _); end
  def self.tracked?(path); end
end

Overcommit::GitRepo::DIFF_HUNK_REGEX = T.let(T.unsafe(nil), Regexp)

Overcommit::GitRepo::SUBMODULE_STATUS_REGEX = T.let(T.unsafe(nil), Regexp)

class Overcommit::GitRepo::Submodule < ::Struct
  def path; end
  def path=(_); end
  def url; end
  def url=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class Overcommit::GitRepo::SubmoduleStatus < ::Struct
  def describe; end
  def describe=(_); end
  def merge_conflict?; end
  def outdated?; end
  def path; end
  def path=(_); end
  def prefix; end
  def prefix=(_); end
  def sha1; end
  def sha1=(_); end
  def uninitialized?; end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

Overcommit::HOME = T.let(T.unsafe(nil), String)

Overcommit::HOOK_DIRECTORY = T.let(T.unsafe(nil), String)

module Overcommit::Hook
end

class Overcommit::Hook::Base
  extend(::Forwardable)

  def initialize(config, context); end

  def all_files(*args, &block); end
  def applicable_files; end
  def command; end
  def config; end
  def description; end
  def enabled?; end
  def execute(cmd, options = _); end
  def execute_in_background(cmd); end
  def flags; end
  def in_path?(cmd); end
  def included_files; end
  def modified_files(*args, &block); end
  def name; end
  def parallelize?; end
  def processors; end
  def quiet?; end
  def required?; end
  def required_executable; end
  def required_libraries; end
  def run; end
  def run?; end
  def run_and_transform; end
  def skip?; end

  private

  def applicable_file?(file); end
  def check_for_executable; end
  def check_for_libraries; end
  def check_for_requirements; end
  def install_command_prompt; end
  def process_hook_return_value(hook_return_value); end
  def select_applicable(list); end
  def transform_status(status); end
end

Overcommit::Hook::MESSAGE_TYPES = T.let(T.unsafe(nil), Array)

class Overcommit::Hook::Message < ::Struct
  def content; end
  def content=(_); end
  def file; end
  def file=(_); end
  def line; end
  def line=(_); end
  def to_s; end
  def type; end
  def type=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

module Overcommit::HookContext
  def self.create(hook_type, config, args, input); end
end

class Overcommit::HookContext::Base
  def initialize(config, args, input); end

  def all_files; end
  def cleanup_environment; end
  def execute_hook(command); end
  def hook_class_name; end
  def hook_script_name; end
  def hook_type_name; end
  def input_lines; end
  def input_string; end
  def modified_files; end
  def post_fail_message; end
  def setup_environment; end

  private

  def filter_directories(modified_files); end
  def filter_modified_files(modified_files); end
  def filter_nonexistent(modified_files); end
end

module Overcommit::HookLoader
end

class Overcommit::HookLoader::Base
  def initialize(config, context, logger); end

  def load_hooks; end

  private

  def create_hook(hook_name); end
  def log; end
end

class Overcommit::HookLoader::BuiltInHookLoader < ::Overcommit::HookLoader::Base
  def load_hooks; end
end

class Overcommit::HookLoader::PluginHookLoader < ::Overcommit::HookLoader::Base
  def load_hooks; end
  def update_signatures; end

  private

  def ad_hoc_hook_names; end
  def check_for_modified_plugins; end
  def create_ad_hoc_hook(hook_name); end
  def modified_plugins; end
  def plugin_hook_names; end
  def plugin_paths; end
end

class Overcommit::HookRunner
  def initialize(config, logger, context, printer); end

  def run; end

  private

  def consume; end
  def load_hooks; end
  def log; end
  def print_results; end
  def processors_for_hook(hook); end
  def release_slot(hook); end
  def run_hook(hook); end
  def run_hooks; end
  def should_skip?(hook); end
  def wait_for_slot(hook); end
end

class Overcommit::HookSigner
  def initialize(hook_name, config, context); end

  def hook_name; end
  def hook_path; end
  def signable_file?(file); end
  def signature_changed?; end
  def update_signature!; end

  private

  def hook_contents; end
  def signature; end
  def signature_config_key; end
  def stored_signature; end
end

Overcommit::HookSigner::IGNORED_CONFIG_KEYS = T.let(T.unsafe(nil), Array)

class Overcommit::Installer
  def initialize(logger); end

  def run(target, options); end

  private

  def can_replace_file?(file); end
  def config(options = _); end
  def ensure_directory(path); end
  def hooks_path; end
  def install; end
  def install_hook_files; end
  def install_master_hook; end
  def install_starter_config; end
  def log; end
  def master_hook_install_path; end
  def old_hooks_path; end
  def overcommit_hook?(file); end
  def preserve_old_hooks; end
  def restore_old_hooks; end
  def uninstall; end
  def uninstall_hook_files; end
  def uninstall_master_hook; end
  def update; end
  def validate_target; end
end

Overcommit::Installer::MASTER_HOOK = T.let(T.unsafe(nil), String)

Overcommit::Installer::TEMPLATE_DIRECTORY = T.let(T.unsafe(nil), String)

class Overcommit::Logger
  def initialize(out); end

  def bold(*args); end
  def bold_error(*args); end
  def bold_warning(*args); end
  def debug(*args); end
  def error(*args); end
  def log(*args); end
  def newline; end
  def partial(*args); end
  def success(*args); end
  def warning(*args); end

  private

  def color(code, str, partial = _); end

  def self.silent; end
end

class Overcommit::MessageProcessor
  def initialize(hook, unmodified_lines_setting); end

  def hook_result(messages); end

  private

  def basic_status_and_output(messages); end
  def can_upgrade_to_passing?(status, warning_messages); end
  def can_upgrade_to_warning?(status, error_messages); end
  def handle_modified_lines(messages, status); end
  def message_on_modified_line?(message); end
  def print_messages(messages, error_heading, warning_heading); end
  def remove_ignored_messages(messages); end
  def transform_status(status, messages_on_modified_lines); end
end

Overcommit::MessageProcessor::ERRORS_GENERIC_HEADER = T.let(T.unsafe(nil), String)

Overcommit::MessageProcessor::ERRORS_MODIFIED_HEADER = T.let(T.unsafe(nil), String)

Overcommit::MessageProcessor::ERRORS_UNMODIFIED_HEADER = T.let(T.unsafe(nil), String)

Overcommit::MessageProcessor::WARNINGS_GENERIC_HEADER = T.let(T.unsafe(nil), String)

Overcommit::MessageProcessor::WARNINGS_MODIFIED_HEADER = T.let(T.unsafe(nil), String)

Overcommit::MessageProcessor::WARNINGS_UNMODIFIED_HEADER = T.let(T.unsafe(nil), String)

module Overcommit::OS
  def self.cygwin?; end
  def self.linux?; end
  def self.mac?; end
  def self.unix?; end
  def self.windows?; end
end

Overcommit::OS::SEPARATOR = T.let(T.unsafe(nil), String)

class Overcommit::Printer
  def initialize(config, logger, context); end

  def end_hook(hook, status, output); end
  def hook_run_failed(message); end
  def hook_skipped(hook); end
  def interrupt_triggered; end
  def log; end
  def nothing_to_run; end
  def required_hook_not_skipped(hook); end
  def run_failed; end
  def run_interrupted; end
  def run_succeeded; end
  def run_warned; end
  def start_run; end

  private

  def hook_script_name; end
  def print_header(hook); end
  def print_report(output, format = _); end
  def print_result(hook, status, output); end
  def synchronize_all_methods; end
end

Overcommit::REPO_URL = T.let(T.unsafe(nil), String)

class Overcommit::Subprocess
  def self.spawn(args, options = _); end
  def self.spawn_detached(args); end
end

class Overcommit::Subprocess::Result < ::Struct
  def status; end
  def status=(_); end
  def stderr; end
  def stderr=(_); end
  def stdout; end
  def stdout=(_); end
  def success?; end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

module Overcommit::Utils
  def self.broken_symlink?(file); end
  def self.camel_case(str); end
  def self.convert_glob_to_absolute(glob); end
  def self.execute(initial_args, options = _); end
  def self.execute_in_background(args); end
  def self.git_dir; end
  def self.in_path?(cmd); end
  def self.log; end
  def self.log=(_); end
  def self.matches_path?(pattern, path); end
  def self.parent_command; end
  def self.processor_count; end
  def self.repo_root; end
  def self.script_path(script); end
  def self.snake_case(str); end
  def self.strip_color_codes(text); end
  def self.supported_hook_type_classes; end
  def self.supported_hook_types; end
  def self.with_environment(env); end
end

module Overcommit::Utils::FileUtils
  def self.readlink(link_name); end
  def self.symlink(old_name, new_name); end
  def self.symlink?(file_name); end
end

class Overcommit::Utils::Version < ::Gem::Version
  def !=(version); end
  def <(version); end
  def <=(version); end
  def ==(version); end
  def >(version); end
  def >=(version); end
end

Overcommit::VERSION = T.let(T.unsafe(nil), String)
